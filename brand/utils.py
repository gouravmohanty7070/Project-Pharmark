import numpy as np
from keras.models import load_model
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import Select
# from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.chrome.service import Service
import threading

chars = ['\n', "'", 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' ','_','-','.','/','&','1','2','3','4','5','6','7','8','9','0','+','(',')','>','<','%','`']

char_indices = dict((c, i) for i, c in enumerate(chars))
indices_char = dict((i, c) for i, c in enumerate(chars))

maxlen = 33
minlen = 1
max_names = 50

model = load_model('model.h5')
model_suffix = load_model('model_suffix.h5')

def med_count(medlist):
    finallist=[]
    s=Service(r"C:\Users\rajag\Desktop\chromedriver.exe")
    driver = webdriver.Chrome(service=s)
    for med in medlist:
        driver.get('https://ipindiaonline.gov.in/tmrpublicsearch/frmmain.aspx')
        wait = WebDriverWait(driver, 10)
        # time.sleep(1)
        # driver.implicitly_wait(10)
        select = Select(driver.find_element('id', 'ContentPlaceHolder1_DDLSearchType'))
        select.select_by_value('PH')
        wordmarkelem = driver.find_element(By.CSS_SELECTOR, "#ContentPlaceHolder1_TBPhonetic")
        classelem = driver.find_element(By.CSS_SELECTOR, "#ContentPlaceHolder1_TBClass")
        searchelem = driver.find_element(By.CSS_SELECTOR, "#ContentPlaceHolder1_BtnSearch")
        wordmarkelem.send_keys(med)
        classelem.send_keys("5")
        searchelem.click()
        # count = driver.find_element(By.CSS_SELECTOR, "#ContentPlaceHolder1_LblSearchDetail > table:nth-child(1) > tbody:nth-child(1) > td:nth-child(1)").text
        count = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR,
                                                             "#ContentPlaceHolder1_LblSearchDetail > table:nth-child(1) > tbody:nth-child(1) > tr:nth-child(1) > td:nth-child(1)"))).text

        count = count.split(' ')[-1]
        #         print(count)
        if int(count) > 0 and int(count) <= 80:  # range
            finallist.append(med)
    driver.close()
    return (finallist)


def sample(preds):
    """ function that sample an index from a probability array """
    preds = np.asarray(preds).astype('float64')
    preds = preds / np.sum(preds)
    probas = np.random.multinomial(1, preds, 1)
    return np.random.choice(range(len(chars)), p=probas.ravel())


def print_name_generated(name):
    print(name, flush=True)


def print_list_generated(lst):
    print(lst, flush=True)


def generate_new_names(prefix):
    #     print("----------Generating names----------")

    # Add pre-padding of zeros in the beginning
    prefix = ' ' * (maxlen - len(prefix)) + prefix

    # Generate new names
    for i in range(max_names):
        x_pred = np.zeros((1, maxlen, len(chars)))
        for t, char in enumerate(prefix):
            x_pred[0, t, char_indices[char]] = 1.

        # Use the model to predict the next character
        preds = model.predict(x_pred, verbose=0)[0]
        next_index = sample(preds)
        next_char = indices_char[next_index]

        # Add the predicted character to the prefix
        # and print the generated name
        prefix = prefix[1:] + next_char
        name = prefix.strip()
        print_name_generated(name)


# Use the machine learning model to generate a list of strings
generated_strings = [...generated by machine learning model...]


# Define a function that runs the generate_new_names function with a given prefix
def run_script(prefix):
    generate_new_names(prefix)


# Create a list of threads
threads = []

# Create a new thread for each prefix and append it to the list of threads
for prefix in generated_strings[:5]:
    thread = threading.Thread(target=run_script, args=(prefix,))
    threads.append(thread)

# Start all the threads
for thread in threads:
    thread.start()

# Join all the threads
for thread in threads:
    thread.join()
